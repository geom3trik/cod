use std::vec::Vec;

#[derive(Clone, Debug)]
struct A {
    header: cod::Header,
    some_data: i32,
    child: cod::Child<B>,
    optional_child: Option<cod::Child<B>>,
    child_list: Vec<cod::Child<B>>,
}

#[derive(Clone, Debug)]
struct B {
    header: cod::Header,
    data: Vec<i32>,
}

fn main() {
    let mut state = cod::State::construct(|| {
        let header = cod::Header::new();
        A {
            header: header.clone(),
            some_data: 15,
            child: cod::Child::with_parent_header(&header, B { header: Default::default(), data: [1, 2, 3].to_vec() }),
            optional_child: None,
            child_list: vec![],
        }
    });
    {
        println!("{:#?}", state.root());
        let mut b = state.get_mut(state.root().child.get_ref());
        b.data.push(123);
    }
    println!("{:#?}", state.root());
}

// These would be generated by #[derive]
impl cod::Node for A {
    fn header(&self) -> &cod::Header {
        &self.header
    }
    fn header_mut(&mut self) -> &mut cod::Header {
        &mut self.header
    }
}

impl cod::Node for B {
    fn header(&self) -> &cod::Header {
        &self.header
    }
    fn header_mut(&mut self) -> &mut cod::Header {
        &mut self.header
    }
}
